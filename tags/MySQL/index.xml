<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MySQL on Jakseer&#39;s Blog</title>
    <link>https://blog.jakseer.com/tags/MySQL/</link>
    <description>Recent content in MySQL on Jakseer&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 04 Jul 2021 15:15:23 +0800</lastBuildDate><atom:link href="https://blog.jakseer.com/tags/MySQL/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>总结 MySQL 中的锁</title>
      <link>https://blog.jakseer.com/post/the-summary-of-lock-in-mysql/</link>
      <pubDate>Sun, 04 Jul 2021 15:15:23 +0800</pubDate>
      
      <guid>https://blog.jakseer.com/post/the-summary-of-lock-in-mysql/</guid>
      <description>众所周知，mysql 中有很多种锁的概念，如行锁、乐观锁、排它锁等等，本文对此进行归纳。 锁的类型 加锁类型的不同，表现在对竞争资源的处理有不同的处理思想。 假设有这样的场景，A、B 两个用户要同时将机票价格从 2 元改成 6、3 元。 乐观锁 取数据时，假定别人不会修改该数据，因此只会对数据做简单的</description>
    </item>
    
    <item>
      <title>InnoDB 幻读简述</title>
      <link>https://blog.jakseer.com/post/innodb-phantom-reads-summary/</link>
      <pubDate>Sat, 15 Aug 2020 16:27:47 +0800</pubDate>
      
      <guid>https://blog.jakseer.com/post/innodb-phantom-reads-summary/</guid>
      <description>什么是幻读 幻读，即某个事务在执行两次相同的 select 操作中，另一个事务插入了一条数据，导致两次 select 读取出的数据不同，会多出另一个事务插入的数据，违反了事务的隔离性。 举个例子，下图是两个事务，第 3、5 步执行了相同的 sql 查询语句，但是后一次查询比前一次查询，多出了 age = 10 的这一条数据。 MySQL 的 InnoDB 存储引</description>
    </item>
    
  </channel>
</rss>
